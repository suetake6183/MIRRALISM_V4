# MIRRALISM_V4 - 人間関係分析システム

## プロジェクト概要
- **目的**: 末武さんの議事録や思考メモをClaude Codeが自律的に分析し、人間関係の洞察を提供するシステム
- **技術スタック**: Node.js + SQLite + Claude Code連携
- **ワークフロー**: 直接分析→学習データ適用→結果保存（効率重視）

## 重要な制約（必須遵守）
- **APIは使わない**（Claude Code内で直接分析）
- **非エンジニア向け**（エラーは日本語、操作は簡単）
- **段階的実装**（1日1機能）
- **JST時刻**（すべてのタイムスタンプは日本標準時）

## 🔄 効率的ワークフロー（現行版）

### 分析プロセス
1. **学習データ確認**: 分析前に最新の修正データを確認
2. **直接分析実行**: Claude Codeが学習データを適用して即座に分析
3. **結果保存**: 分析結果を自動的に学習データベースに蓄積
4. **継続的改善**: 蓄積されたデータで次回分析の精度向上

**設計変更理由**: 提案→承認フローは精度が低く非効率のため、直接分析方式を採用

## 🗂️ **LLM中心の大規模ファイル管理システム（新設計）**

### **インテリジェント・ファイル管理の原則**
**Claude Codeが100件以上のファイルを効率的に管理するシステム**

#### **1. 自動メタデータ生成**
```javascript
// Claude Codeが分析時に自動生成すべきメタデータ
const smartMetadata = {
  // 基本情報
  sourceFile: "社労士_下重さん.txt",
  analysisDate: "2025-01-17",
  
  // LLMが自動抽出
  category: "meeting-analysis", // 会議分析
  participants: ["末武さん", "下重さん"], // 参加者自動抽出
  topics: ["年度更新", "契約変更", "AI導入"], // トピック自動抽出
  priority: "high", // 重要度自動判定
  
  // 関連性分析
  relatedFiles: ["analysis_shimoju_20250115_v1.json"], // 関連ファイル自動検出
  keyInsights: ["契約形態変更", "助成金活用"], // 重要洞察の抽出
  
  // 管理情報
  archiveDate: "2025-04-17", // 3ヶ月後を自動計算
  searchTags: ["社労士", "契約", "AI", "助成金"] // 検索用タグ自動生成
}
```

#### **2. 階層化ディレクトリ構造**
```
output/analysis_results/
├── 2025/
│   ├── Q1-business/ (ビジネス関連)
│   │   ├── meeting-analysis/
│   │   ├── contract-changes/
│   │   └── ai-integration/
│   └── Q1-personal/ (個人関連)
│       ├── profiles/
│       └── insights/
├── learning-data/
│   ├── speech-patterns/
│   ├── relationship-dynamics/
│   └── business-contexts/
└── system-management/
    ├── metadata-index/
    └── auto-cleanup/
```

#### **3. 自然言語検索システム**
**Claude Codeが理解すべき検索クエリ例**:
- "末武さんの会議で助成金の話があったファイル"
- "2024年の労務関係の分析結果"
- "契約変更に関する最新の議論"
- "SKコームの詳細情報が含まれるファイル"

#### **4. 自動分類・整理ルール**
```javascript
// Claude Codeが実装すべき自動分類ロジック
const autoClassification = {
  // 重要度判定
  priority: {
    high: ["契約", "法的", "緊急", "期限"],
    medium: ["相談", "検討", "提案"],
    low: ["雑談", "日常", "メモ"]
  },
  
  // カテゴリ自動判定
  category: {
    "meeting-analysis": ["参加者", "議題", "打ち合わせ"],
    "personal-profile": ["性格", "特徴", "行動パターン"],
    "business-strategy": ["戦略", "計画", "ビジネスモデル"],
    "learning-data": ["修正", "学習", "パターン"]
  },
  
  // 自動アーカイブ条件
  archive: {
    after3Months: ["一時的な分析", "テストデータ"],
    after6Months: ["詳細ログ", "中間結果"],
    permanent: ["重要な洞察", "学習データ", "プロファイル"]
  }
}
```

### **Claude Codeへの具体的実装指示**

#### **必須実装項目**:

1. **分析実行時の自動メタデータ生成**
   ```javascript
   // 各分析実行時に以下を自動生成
   const analysisResult = {
     // 既存の分析内容
     ...existingAnalysis,
     
     // 新規追加: 自動メタデータ
     metadata: {
       autoGenerated: true,
       category: await this.detectCategory(content),
       participants: await this.extractParticipants(content),
       topics: await this.extractTopics(content),
       priority: await this.assessPriority(content),
       searchTags: await this.generateSearchTags(content),
       relatedAnalyses: await this.findRelatedFiles(content),
       archiveDate: this.calculateArchiveDate(),
       createdAt: getJSTTimestamp()
     }
   }
   ```

2. **インテリジェント・ファイル命名**
   ```javascript
   // 内容に基づく自動ファイル名生成
   const generateSmartFileName = (content, metadata) => {
     const type = metadata.category.replace('-', '_');
     const mainTopic = metadata.topics[0]?.replace(/[^a-zA-Z0-9]/g, '_');
     const date = new Date().toISOString().slice(0,10).replace(/-/g, '');
     
     return `${type}_${mainTopic}_${date}.json`;
   }
   ```

3. **自動ディレクトリ配置**
   ```javascript
   // 内容とメタデータに基づく最適配置
   const determineOptimalPath = (metadata) => {
     const year = new Date().getFullYear();
     const quarter = `Q${Math.ceil((new Date().getMonth() + 1) / 3)}`;
     const category = metadata.category;
     
     return `output/analysis_results/${year}/${quarter}-business/${category}/`;
   }
   ```

4. **重複検出・統合システム**
   ```javascript
   // 同一内容の検出と統合
   const checkForDuplicates = async (newAnalysis) => {
     const existingFiles = await this.findSimilarContent(newAnalysis);
     if (existingFiles.length > 0) {
       return await this.mergeWithExisting(newAnalysis, existingFiles[0]);
     }
     return newAnalysis;
   }
   ```

#### **Claude Code実行時の必須チェックリスト**:

**分析開始前**:
- [ ] 学習データベースから最新パターンを取得
- [ ] 類似ファイルの存在確認
- [ ] 適切なディレクトリ構造の確認

**分析実行中**:
- [ ] 自動メタデータ生成
- [ ] カテゴリ・重要度の自動判定
- [ ] 参加者・トピックの自動抽出
- [ ] 関連ファイルの自動検出

**分析完了後**:
- [ ] 最適なディレクトリへの自動配置
- [ ] 重複ファイルの統合処理
- [ ] 検索インデックスの更新
- [ ] 学習データベースへの保存

## 🧠 学習データ（Claude Code分析時に必須参照）

### 分析前の学習データ確認手順
**すべての分析実行前に**、以下のコマンドで最新の学習データを確認してください：

```bash
# 最新の関係性修正データを確認
sqlite3 database/learning.db "SELECT pattern_description, pattern_details FROM learning_patterns WHERE pattern_description LIKE '%関係性修正%' ORDER BY created_at DESC LIMIT 3;"

# ファイル種別判定の学習データを確認  
sqlite3 database/learning.db "SELECT pattern_description, pattern_details FROM learning_patterns WHERE pattern_description LIKE '%判定%' ORDER BY created_at DESC LIMIT 3;"

# Claude Code分析結果の学習データを確認
sqlite3 database/learning.db "SELECT pattern_description, created_at FROM learning_patterns WHERE pattern_description LIKE '%Claude Code%' ORDER BY created_at DESC LIMIT 3;"
```

### 学習データ活用のポイント
- **関係性修正**: ユーザーが手動修正した情報を優先適用
- **話し方パターン**: 末武さんの言語特徴（「〜っすよ」等）を理解
- **ビジネス文脈**: SKコーム詳細、守成クラブ関係等の背景情報

## 📊 分析後の学習データ保存

分析完了後は以下のコマンドで結果を学習データベースに保存：
```bash
npm run save-claude-analysis
```

## 🛠️ 開発・保守コマンド

### 基本操作
```bash
npm run analyze          # メイン分析実行
npm run init-db         # データベース初期化
npm run quality-check   # 品質チェック実行
```

### 学習データ管理
```bash
npm run save-claude-analysis  # Claude Code結果保存
sqlite3 database/learning.db ".tables"  # テーブル確認
```

## 📁 ファイル構造

### 重要ディレクトリ
- `scripts/core/`: メイン分析エンジン
- `scripts/analytics/`: 学習データ管理
- `output/analysis_results/`: 分析結果保存（統合構造）
- `database/`: 学習データベース（SQLite）

### 設定ファイル
- `package.json`: 依存関係とスクリプト定義
- `CLAUDE.md`: 本ファイル（Claude Code用設定書）

## 🎯 品質保証

### 設計制約
- 装飾的ログ使用禁止（プロフェッショナル性重視）
- 外部API使用禁止（Claude Code内完結）
- 環境変数使用禁止（設定ファイル管理）

### 品質チェック項目
- コード重複チェック（jscpd）
- 循環依存チェック（madge）
- 未使用コード検出（knip）

## 📈 継続的改善

システムは使用により自動的に学習・改善されます：
- ユーザーの修正情報を永続保存
- 分析パターンの蓄積
- 精度の継続的向上

## システムの流れ
1. inputフォルダにファイルを配置
2. **学習データを確認**（上記セクション参照）
3. AIがファイル種類を自動判別（meeting/personal/proposal）
4. **学習データを適用して分析実行**
5. 分析実行・結果保存
6. **フィードバックで学習データ更新**
7. ファイルを自動アーカイブ

## 🎯 Task Master AI による進捗管理
**重要：進捗管理と作業計画はTask Master AIを参照すること**

### 作業開始前の必須手順
1. **Task Master AIで次のタスク確認**: `next_task`機能で優先タスクを特定
2. **詳細な実装計画確認**: 各タスクのサブタスクで具体的な実装手順を確認
3. **依存関係の確認**: 前提タスクが完了していることを確認

### 実装中の記録
- **作業ログ記録**: 実装中の気づきは`update_subtask`で詳細に記録
- **方針変更時の調整**: `update_task`で実装方針の変更を反映

### 完了処理
- **テスト実行**: タスクの`testStrategy`に基づいて検証
- **ステータス更新**: `set_task_status`で完了状態に変更

## 開発コマンド
- `npm run analyze`: 分析実行
- `npm run init-db`: データベース初期化
- `npm run quality`: 包括的品質チェック実行
- `npm run test`: システムテスト実行

## ディレクトリ構造
- `scripts/core/`: 中核機能（analyze.js, db-setup.js）
- `scripts/search/`: 検索関連機能
- `scripts/analytics/`: 分析・効果測定
- `scripts/testing/`: テスト関連
- `scripts/security/`: セキュリティ関連
- `scripts/visualization/`: 可視化関連
- `scripts/shared/`: 共通ユーティリティ（logger.js, quality-checker.js）

## データベース構造
- `database/learning.db`: 学習パターン保存
- `database/profiles.db`: 人物プロファイル
- `database/archive-index.db`: アーカイブインデックス

## 品質管理
- **設計書制約100%遵守**: 環境変数禁止、API禁止、装飾ログ禁止、バックグラウンド処理禁止
- **自動品質チェック**: jscpd（重複検出）、madge（循環依存）、knip（未使用コード）
- **品質スコア**: 現在85%（目標90%以上）

## ⚠️ Claude Code への重要指示
**Task Master AIが全ての作業管理を行います：**

1. **作業開始前**: Task Master AIで次のタスクを確認
2. **作業中**: サブタスクの実装手順に従い、進捗を記録
3. **作業完了**: Task Master AIでステータス更新

**このCLAUDE.mdは概要把握のみ。詳細はTask Master AIを参照すること。**

## 🚀 **Claude Code実行時の必須手順**

### **分析実行前のチェックリスト**:
```bash
# 1. 学習データベースの最新状況確認
sqlite3 database/learning.db "SELECT COUNT(*) as total_patterns FROM learning_patterns;"

# 2. 既存分析ファイルの確認
ls -la output/analysis_results/

# 3. システム準備確認
npm run init-db
```

### **分析実行コマンド**:
```bash
# メイン分析実行（LLM中心ファイル管理システム使用）
npm run analyze
```

### **実行後の自動処理**:
- ✅ 自動メタデータ生成（カテゴリ、参加者、トピック、重要度）
- ✅ インテリジェント・ファイル命名
- ✅ 最適ディレクトリ配置
- ✅ 重複ファイル検出・統合
- ✅ 検索タグ自動生成
- ✅ 関連ファイル自動検出
- ✅ 学習データベース更新

### **Claude Code分析時の期待される出力例**:
```
🤖 自動メタデータ生成完了
📂 カテゴリ: meeting-analysis
👥 参加者: 末武, 下重さん
🏷️ トピック: 年度更新, 契約変更, AI導入
⭐ 重要度: high
🎯 LLM中心ファイル管理システムによる保存完了
📁 保存場所: output/analysis_results/meeting_analysis_年度更新_20250117.json
🗂️ 自動分類: meeting-analysis
🏷️ 検索タグ: 社労士, 契約, AI
```

### **トラブルシューティング**:
```bash
# 重複ファイルが作成された場合
npm run cleanup-duplicates

# 分析統計の確認
node -e "const OutputManager = require('./scripts/shared/output-manager'); const manager = new OutputManager(); manager.getAnalysisStatistics().then(stats => console.log(JSON.stringify(stats, null, 2)));"

# 学習データの確認
sqlite3 database/learning.db "SELECT pattern_description, created_at FROM learning_patterns ORDER BY created_at DESC LIMIT 5;"
```

## ファイル作成・編集ルール
### 改行コード
- ファイルの終端は必ずLF（\n）にする
- 既に終端がLFの場合は追加しない

### フォーマット
- 空白だけの行は改行文字のみにする
- 文章の末尾の空白は削除する
- 行末に不要な空白文字を残さない

# Claude Code 実行指示書

## 基本方針
- **日本語優先**: すべての処理と報告は日本語で実行
- **段階的実装**: 1日1機能の原則
- **Task Master AI連携**: 作業前後の確認必須

## 人間関係分析の実行手順

### 📋 **新機能: 二重出力システム**

ファイル分析時は、以下の二重出力システムを使用してください：

#### **1. AI学習用データ (output/ai_learning/)**
```javascript
// AI学習用の構造化JSONデータを自動保存
const analyzer = new HumanRelationshipAnalyzer();
const result = await analyzer.analyzeFile(filePath);
```

#### **2. 人間向け成果物 (output/deliverables/)**
以下の読みやすい成果物を自動生成：

**プロファイル** (`output/deliverables/profiles/`)
```markdown
# [名前]さんのプロファイル
## 📊 基本情報
## 🎯 特徴的なパターン  
## 💬 コミュニケーションスタイル
## 🤝 人間関係における役割
## 📈 ビジネス・専門分野での強み
```

**会議サマリー** (`output/deliverables/meeting_summaries/`)
```markdown
# 会議サマリー
## 📅 会議情報
## 📋 主要な議論内容
## 👥 参加者別の発言傾向
## 🔄 次回までのアクション
```

**洞察レポート** (`output/deliverables/insights_reports/`)
```markdown
# 分析洞察レポート
## 🔍 主要な発見事項
## 🚀 推奨アクション
```

### 📋 **必須: 詳細分析プロセス報告**

ファイル分析を実行する際は、以下の詳細なプロセス報告を**必ず**提供してください：

#### **1. 分析前の準備報告**
```
🔍 分析対象: [ファイル名・参加者・日時]
📊 分析手法:
- 使用する分析フレームワーク
- 重視する観点（関係性・感情・影響力・コミュニケーションパターン等）
- 学習データ活用方針
```

#### **2. 段階別分析プロセス報告**
```
📋 ステップ1: 構造化読み取り
- 参加者特定: [具体的な判定根拠]
- 発言量分析: [数値化された結果]
- 話題分類: [カテゴリ分けの基準と結果]

📋 ステップ2: 関係性分析
- 権力構造: [上下関係・影響力の分析根拠]
- 感情的関係: [協調・対立・中立の判定基準]
- コミュニケーションパターン: [具体的な発言例と分析]

📋 ステップ3: 深層洞察抽出
- 表面的事実 vs 深層的洞察の区別
- 因果関係の特定: [A→Bの関係性とその根拠]
- 将来予測: [パターンから導かれる予測]
```

#### **3. 品質評価と信頼度報告**
```
📊 分析結果の品質評価:
- 網羅性: XX%（理由: ○○は詳細分析、△△は表面的）
- 深度: XX%（理由: ○○の因果関係は明確、△△は推測レベル）
- 新規性: XX%（理由: ○○パターンは既存データにない新発見）
- 信頼度: XX%（理由: データ量・一貫性・検証可能性）
```

#### **4. 学習パターン抽出の詳細報告**
```
📚 新規学習パターンの詳細:
1. パターン名: [具体的な名称]
   - 抽出根拠: [なぜこのパターンを特定したか]
   - 重要度: [高/中/低とその理由]
   - 適用範囲: [どのような場面で活用可能か]
   - 検証方法: [パターンの正確性をどう確認するか]
```

#### **5. 出力ファイル報告**
```
📁 生成された成果物:
✅ AI学習データ: output/ai_learning/raw_analysis/[ファイル名]
✅ 人間向け成果物:
   - プロファイル: output/deliverables/profiles/[ファイル名]
   - 会議サマリー: output/deliverables/meeting_summaries/[ファイル名]
   - 洞察レポート: output/deliverables/insights_reports/[ファイル名]
```

### 📝 **分析実行コマンド例**

```javascript
// 新しい二重出力システムの使用
const analyzer = new HumanRelationshipAnalyzer();
const result = await analyzer.analyzeFile('input/会議録.txt');

// 結果の確認
console.log('AI学習データ:', result.aiData);
console.log('人間向け成果物:', result.humanDeliverables);
```

### ⚠️ **禁止事項**
- 結果のみの報告（プロセスの省略禁止）
- 根拠不明な洞察の提示
- 学習パターンの価値評価なしでの保存
- 旧出力システム（analysis_results）の使用

### ✅ **成功基準**
- 分析手法が明確に説明されている
- 各洞察に具体的な根拠が示されている
- 品質評価が数値化されている
- 学習価値が明確に評価されている
- AI学習用と人間向けの両方の成果物が生成されている

## ファイル出力規則

### 📁 **ディレクトリ構造**
```
output/
├── ai_learning/           # AI学習専用データ
│   ├── raw_analysis/      # 生の分析結果JSON
│   ├── learning_patterns/ # 抽出された学習パターン
│   └── metadata/          # メタデータ
└── deliverables/          # 人間向け成果物
    ├── profiles/          # 個人プロファイル.md
    ├── meeting_summaries/ # 会議サマリー.md
    ├── insights_reports/  # 洞察レポート.md
    ├── relationship_maps/ # 関係性マップ
    ├── action_items/      # アクションアイテム
    └── templates/         # テンプレート
```

### 📝 **ファイル命名規則**
```
AI学習用: YYYYMMDD_[タイプ]_[ソース].json
人間向け: YYYYMMDD_[内容]_[名前].md

例:
- 20250617_meeting-analysis_前田久仁子.json
- 20250617_会議サマリー.md
- 20250617_前田久仁子_プロファイル.md
``` 